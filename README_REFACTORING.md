# Рефакторинг JarvisDND - Разбиение монолита

## Обзор изменений

Монолитный файл `app.py` был разбит на модульную архитектуру для улучшения организации кода, читаемости и поддерживаемости.

## Новая структура проекта

```
JarvisDND/
├── app.py                 # Старый монолитный файл (сохранен для сравнения)
├── app_new.py            # Новый главный файл приложения
├── config.py             # Конфигурация приложения
├── models.py             # Модели базы данных
├── auth.py               # Аутентификация и OAuth
├── routes/               # Маршруты приложения
│   ├── __init__.py
│   ├── main.py          # Основные маршруты (index, login, dashboard, logout)
│   ├── chat.py          # API чата
│   ├── prompts.py       # API промптов
│   └── images.py        # API изображений
├── services/            # Бизнес-логика
│   ├── __init__.py
│   ├── chat_service.py  # Логика чата
│   ├── image_service.py # Генерация изображений
│   └── prompt_service.py # Работа с промптами
└── utils/               # Утилиты
    ├── __init__.py
    └── prompt_utils.py  # Работа с файлами промптов
```

## Основные улучшения

### 1. Разделение ответственности
- **Модели** (`models.py`) - только структура данных
- **Сервисы** (`services/`) - бизнес-логика
- **Маршруты** (`routes/`) - обработка HTTP-запросов
- **Конфигурация** (`config.py`) - настройки приложения

### 2. Использование Blueprint
- Каждый тип маршрутов теперь в отдельном Blueprint
- Лучшая организация URL-префиксов
- Возможность независимого тестирования

### 3. Сервисный слой
- Вся бизнес-логика вынесена в сервисы
- Маршруты только обрабатывают HTTP-запросы
- Легче тестировать и переиспользовать код

### 4. Application Factory Pattern
- Функция `create_app()` для создания приложения
- Лучшая поддержка тестирования
- Возможность создания нескольких экземпляров приложения

## Как использовать новую структуру

### Запуск приложения
```bash
# Использовать новый файл
python app_new.py

# Или переименовать
mv app.py app_old.py
mv app_new.py app.py
python app.py
```

### Структура импортов
```python
# В маршрутах
from services.chat_service import ChatService
from models import User, ChatSession

# В сервисах
from models import db, ChatMessage
from utils.prompt_utils import get_system_prompt
```

## Преимущества новой архитектуры

1. **Читаемость** - каждый файл имеет одну ответственность
2. **Поддерживаемость** - легче находить и изменять код
3. **Тестируемость** - можно тестировать сервисы независимо
4. **Масштабируемость** - легко добавлять новые функции
5. **Переиспользование** - сервисы можно использовать в разных частях приложения

## Миграция

1. Сохраните старый `app.py` как `app_old.py`
2. Переименуйте `app_new.py` в `app.py`
3. Убедитесь, что все зависимости установлены
4. Протестируйте все функции приложения

## Возможные дальнейшие улучшения

1. Добавить логирование
2. Создать тесты для каждого модуля
3. Добавить обработку ошибок
4. Реализовать кэширование
5. Добавить документацию API 

## Настройка стабильного взаимодействия с AI

`services/ai_client.py` реализует рекомендации из `documentation_ru/ИСПОЛЬЗОВАНИЕ_БЕСПЛАТНЫХ_ПРОВАЙДЕРОВ.md`.  
Клиент использует бесплатные провайдеры через `RetryProvider`, автоматически перемешивает их и повторно пытается выполнить запросы при сбоях.

Переменные окружения для тонкой настройки:

- `G4F_FREE_PROVIDERS` — пробел-разделённый список провайдеров (по умолчанию OperaAria, Chatai, WeWordle, Startnest)
- `G4F_CHAT_MODEL` / `G4F_IMAGE_MODEL` — модели по умолчанию для текста и изображений
- `AI_CLIENT_MAX_ATTEMPTS` — число внешних повторов, поверх внутренних `RetryProvider`
- `AI_CLIENT_BACKOFF_SECONDS` — базовая задержка между повторными попытками
- `AI_PROVIDER_MAX_RETRIES` — сколько раз `RetryProvider` пробует каждого провайдера

При необходимости можно переиспользовать `StableAIClient` в других сервисах:

```python
from services.ai_client import StableAIClient

client = StableAIClient()
print(client.describe())
```